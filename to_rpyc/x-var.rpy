label starting_vars:
    python:
        ctime = Calendar(hours=9, minutes=0, day_of_week=2, month=5, monthday=1, year=2024)
        fcs = Player_character()
        tyler = NPC_character(name='tyler', intrigue=0, love=10, fidelity=5, s_power=6, s_count_max=2, desire=0, s_approval=0, corruption=10, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={
        1: [ 
            (0.0, 7.5, "bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "kitchen"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ],
        2: [ 
            (0.0, 7.5, "bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "kitchen"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ],
        3: [ 
            (0.0, 7.5, "bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "kitchen"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ],
        4: [ 
            (0.0, 7.5, "bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "kitchen"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ],
        5: [ 
            (0.0, 7.5, "bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "kitchen"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ],
        6: [ 
            (0.0, 8.5, "bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 13.5, "garden"),
            (14.0, 17.5, "livingroom"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "bar"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ],
        7: [ 
            (0.0, 8.5, "bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 17.5, "livingroom"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "bedroom")
        ]
    }) 
        boss_char = NPC_character(name='boss', intrigue=10, love=0, fidelity=0, s_power=8, s_count_max=2, desire=0, s_approval=0, corruption=10, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={
        1: [ 
            (9.0, 16.5, "town_work")
        ],
        2: [ 
            (9.0, 16.5, "town_work")
        ],
        3: [ 
            (9.0, 16.5, "town_work")
        ],
        4: [ 
            (9.0, 16.5, "town_work")
        ],
        5: [ 
            (9.0, 16.5, "town_work")
        ]
    }) 
        justin = NPC_character(name='justin', intrigue=0, love=0, fidelity=0, s_power=0, s_count_max=2, desire=0, s_approval=0, corruption=0, cuckold=0, free_relations=2, ill=0, viagra=0, love_fam=10, schedule={
        6: [ 
            (20.0, 22.5, "bar")],
        7: [ 
            (12.0, 13.5, "fitness"),
            (20.0, 22.5, "bar")]
    }) 
        shelley = NPC_character(name='shelley', intrigue=5, love=0, fidelity=0, s_power=0, s_count_max=2, desire=0, s_approval=0, corruption=15, cuckold=0, free_relations=3, ill=0, viagra=0, love_fam=20, schedule={
        6: [ 
            (20.0, 22.5, "bar")],
        7: [ 
            (12.0, 13.5, "fitness"),
            (20.0, 22.5, "bar")]
    }) 
        dylan = NPC_character(name='dylan', intrigue=15, love=5, fidelity=0, s_power=7, s_count_max=3, desire=0, s_approval=0, corruption=20, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={
        1: [ 
            (0.0, 8.5, "guest_bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 16.5, "photo"),
            (17.0, 17.5, "garden"),
            (18.0, 18.5, "kitchen"),
            (19.0, 20.5, "livingroom"),
            (21.0, 21.5, "bathroom"),
            (22.0, 23.5, "guest_bedroom")
        ],
        2: [ 
            (0.0, 8.5, "guest_bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 16.5, "photo"),
            (17.0, 17.5, "garden"),
            (18.0, 18.5, "kitchen"),
            (19.0, 20.5, "livingroom"),
            (21.0, 21.5, "bathroom"),
            (22.0, 23.5, "guest_bedroom")
        ],
        3: [ 
            (0.0, 8.5, "guest_bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 16.5, "photo"),
            (17.0, 17.5, "garden"),
            (18.0, 18.5, "kitchen"),
            (19.0, 20.5, "livingroom"),
            (21.0, 21.5, "bathroom"),
            (22.0, 23.5, "guest_bedroom")
        ],
        4: [ 
            (0.0, 8.5, "guest_bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 16.5, "photo"),
            (17.0, 17.5, "garden"),
            (18.0, 18.5, "kitchen"),
            (19.0, 20.5, "livingroom"),
            (21.0, 21.5, "bathroom"),
            (22.0, 23.5, "guest_bedroom")
        ],
        5: [ 
            (0.0, 8.5, "guest_bedroom"),
            (9.0, 9.5, "bathroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 16.5, "photo"),
            (17.0, 17.5, "garden"),
            (18.0, 18.5, "kitchen"),
            (19.0, 20.5, "livingroom"),
            (21.0, 21.5, "bathroom"),
            (22.0, 23.5, "guest_bedroom")
        ],
        6: [ 
            (0.0, 7.5, "guest_bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "livingroom"),
            (10.0, 13.5, "garden"),
            (14.0, 17.5, "photo"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "bar"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "guest_bedroom")
        ],
        7: [ 
            (0.0, 7.5, "guest_bedroom"),
            (8.0, 8.5, "bathroom"),
            (9.0, 9.5, "livingroom"),
            (10.0, 10.5, "kitchen"),
            (11.0, 11.5, "fitness"),
            (12.0, 17.5, "photo"),
            (18.0, 18.5, "kitchen"),
            (19.0, 21.5, "livingroom"),
            (22.0, 22.5, "bathroom"),
            (23.0, 23.5, "guest_bedroom")
        ]}) 
        victor = NPC_character(name='victor', intrigue=20, love=0, fidelity=0, s_power=9, s_count_max=3, desire=0, s_approval=0, corruption=20, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={
        1: [ 
            (9.0, 16.5, "town_work")
        ],
        2: [ 
            (9.0, 16.5, "town_work")
        ],
        3: [ 
            (9.0, 16.5, "town_work")
        ],
        4: [ 
            (9.0, 16.5, "town_work")
        ],
        5: [ 
            (9.0, 16.5, "town_work")
        ]
    }) 
        samantha = NPC_character(name='samantha', intrigue=10, love=0, fidelity=0, s_power=0, s_count_max=0, desire=0, s_approval=0, corruption=10, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={
        6: [ 
            (20.0, 22.5, "bar")],
        7: [ 
            (12.0, 13.5, "fitness"),
            (20.0, 22.5, "bar")]
    }) 

        amelia = NPC_character(name='amelia', intrigue=10, love=0, fidelity=0, s_power=0, s_count_max=0, desire=0, s_approval=0, corruption=10, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={}) 

        jill = NPC_character(name='jill', intrigue=0, love=0, fidelity=0, s_power=0, s_count_max=0, desire=0, s_approval=0, corruption=5, cuckold=0, free_relations=5, ill=0, viagra=0, love_fam=0, schedule={}) 

        liliana = NPC_character(name='liliana', intrigue=2, love=0, fidelity=0, s_power=0, s_count_max=0, desire=0, s_approval=0, corruption=1, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=1, schedule={}) 

        meggy = NPC_character(name='meggy', intrigue=10, love=0, fidelity=0, s_power=0, s_count_max=0, desire=0, s_approval=0, corruption=10, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, schedule={}) 

        sofy = NPC_character(name='sofy', intrigue=17, love=0, fidelity=0, s_power=0, s_count_max=0, desire=0, s_approval=0, corruption=19, cuckold=0, free_relations=5, ill=0, viagra=0, love_fam=0, schedule={}) 

        npcs_list = [tyler]
        npcs_list2 = []
        npcs_list3 = []

        manager = NPCManager(ctime)










        quest_fing = Journal("hide_fing")
        quest_sm = Journal("shower_mast")
        quest_sex = Journal("sex_tracker")


        main_1 = Journal("main_1", branch="main")
        main_2 = Journal("main_2", branch="main")
        main_3 = Journal("main_3", branch="main")
        main_4 = Journal("main_4", branch="main")
        main_5 = Journal("main_5", branch="main")
        main_6 = Journal("main_6", branch="main")


        character_1 = Journal("character_1", branch="character")
        character_2 = Journal("character_2", branch="character")
        character_3 = Journal("character_3", branch="character")
        character_4 = Journal("character_4", branch="character")
        character_5 = Journal("character_5", branch="character")
        character_6 = Journal("character_6", branch="character")
        character_7 = Journal("character_7", branch="character")
        character_8 = Journal("character_8", branch="character")
        character_9 = Journal("character_9", branch="character")
        character_10 = Journal("character_10", branch="character")


        quest_1 = Journal("quest_1", branch="quest")


        work_1 = Journal("work_1", branch="work")


        poss_1 = Journal("poss_1", branch="poss")
        poss_2 = Journal("poss_2", branch="poss")
        poss_3 = Journal("poss_3", branch="poss")


        main_quests = [main_1, main_2, main_3, main_4, main_5, main_6]
        character_quests = [character_1, character_2, character_3, character_4, character_5, character_6, character_7, character_8, character_9, character_10]
        quest_quests = [quest_1]
        work_quests = [work_1]
        poss_quests = []

        fcs.loc = 'home' 
        locs_list = ['bathroom', 'bedroom', 'kitchen', 'livingroom', 'town', 'town_work', 'bar', 'restaurant', 'park', 'club', 'fitness', 'garden', 'guest_bedroom']
        manager.update_locations()
        ctime.set_actor(fcs)
        vars = []
        vdc = {}
        difficulty = "normal"
        fantasies = Fantasy()  
        dylan_chat = PhoneChat("emma", "dylan")



    return



python early:
    class Player_character:
        def __init__(self, intrigue=20, intelligence=10, morality=60, corruption=10, style=0, desire=2, energy=20, exg=0, s_exp=5, fitness=0, anal=0, minet=1, deep_minet=1, strip=0, model=0, submissive=0, drunk_status=0, h_rel=15, j_rel=1, bo_rel=1, br_rel=10, grudge=0, illness=0, eat=0, loc='home', money=3000, income=0, vars = [], cum_count=0):
            self.intrigue = intrigue 
            self.intelligence = intelligence 
            self.morality_days_count = 0
            self.morality = morality 
            self.corruption = corruption 
            self.desire = desire 
            self.energy = energy 
            self.exg = exg 
            self.fitness = fitness  
            self.anal_count = 0 
            self.anal = anal  
            self.minet_count = 0 
            self.minet = minet 
            self.deep_minet_count = 0 
            self.deep_minet = deep_minet 
            self.strip = strip 
            self.model = model 
            self.submissive = submissive 
            self.reputation = 0
            self.s_exp = s_exp 
            self.s_count = 0
            self.drunk_status = 0 
            self.climax_count = 0
            self.climax_max = 3
            self.h_rel = h_rel 
            self.j_rel = j_rel 
            self.bo_rel = bo_rel 
            self.br_rel = br_rel 
            self.eat = eat  
            
            self.loc = loc
            self.money = money
            self.income = income
            self.vars = vars if vars else []
            self.cum_count = cum_count
            self.buffs = []  
            self.desire_modifier = 0  
            self.morality_modifier = 0  
            self.grudge = grudge  
            self.illness = illness 
            self.active_effects = {}
            self.temporary_modifiers = {}
            self.limits = {
            "intrigue": (0, 100),
            "intelligence": (0, 100),
            "morality": (0, 100),
            "corruption": (0, 100),
            "style": (0, 15),
            "permanent_items": (0, 30),
            "looks": (0, 50),
            "desire": (0, 8),
            "energy": (0, 25),
            "exg": (0, 50),
            "fitness": (0, 50),
            "anal": (0, 6),
            "minet": (0, 4),
            "deep_minet": (0, 4),
            "strip": (0, 20),
            "model": (0, 10),
            "submissive": (0, 10),
            "s_exp": (0, 20),
            "drunk_status": (0, 3),
            "h_rel": (0, 30),
            "j_rel": (0, 20),
            "bo_rel": (0, 20),
            "br_rel": (0, 20),
            "eat": (0, 4),
            "cum_count": (0, 3)
        }
            self.BASE_LOOK = 5  
            self.permanent_items = 0  
            self.style = style 
            self.style_buffs = []  
            self.STYLE_BUFF_TYPES = ['health', 'makeup', 'tan', 'hairstyling', 'coloring', 'manicure', 'skincare', 'massage'] 
            self.drunk_buff_active = False  
            self.base_morality = morality  
            self.inv = []
            self.comfort = 0
        
        def __getstate__(self):
            return self.__dict__
        
        def __setstate__(self, state):
            
            self.__dict__ = state
            if 'inv' not in self.__dict__:
                self.inv = []  
            if 'comfort' not in self.__dict__:    
                self.comfort = 0  
            self.limits["strip"] = (0, 20)    
        
        def update(self, stat_name, value):
            if stat_name == "drunk_status":
                raise AttributeError("drunk_status нельзя изменять через update, используй add_drunk_buff")
            
            current_value = getattr(self, stat_name)
            if stat_name == "desire" and current_value == 9 and value != -9:
                return    
            old_value = current_value
            new_value = current_value + value
            min_val, max_val = self.limits.get(stat_name, (None, None))
            
            if min_val is not None and max_val is not None:
                new_value = max(min_val, min(max_val, new_value))
            
            
            if value != 0 and stat_name in ("intrigue", "intelligence", "morality", "corruption", "desire", "energy", "exg", "fitness", "strip", "model", "submissive", "reputation", "permanent_items", "money"):
                stat_loc = get_local(f"s_{stat_name}")
                if value > 0:
                    flying_text(get_local("stat_increase").format(stat_loc, abs(value)), "positive")
                else:
                    flying_text(get_local("stat_decrease").format(stat_loc, abs(value)), "negative")   
            
            
            if stat_name == "energy":
                if new_value <= 2:
                    flying_text(get_local("energy_critical"), "negative")
                elif new_value <= 5:
                    flying_text(get_local("energy_low"), "negative")        
            
            
            if stat_name == "morality":
                base_morality = self.get_base_morality()
                if base_morality <= 5:
                    self.morality_days_count = 2
                    flying_text(get_local("morality_critical"), "negative")
                    if self.morality_days_count == 0:
                        flying_text(get_local("morality_critical"), "negative")
                elif base_morality <= 10:
                    flying_text(get_local("morality_warning"), "negative")
            
            if stat_name == "corruption":
                if current_value < 50 and new_value > 49:
                    new_value = 49
                    print("Предупреждение: коррупция не может превысить 49.")
                elif current_value >= 50 and new_value < 50:
                    new_value = 50
            
            setattr(self, stat_name, new_value)
            
            if stat_name == "s_count":
                if new_value >= 100:
                    self.climax_max = 5
                elif new_value >= 50:
                    self.climax_max = 4
                else:
                    self.climax_max = 3
        
        @property
        def looks(self):
            """
        Calculate and return the total look value based on the formula:
        looks = BASE_LOOK + permanent_items + style + style_buffs
        """
            total_look = self.BASE_LOOK + self.permanent_items + self.style + self.style_buff
            min_val, max_val = self.limits["looks"]
            return max(min_val, min(max_val, total_look))
        
        @property
        def style_buff(self):
            """Возвращает суммарное значение всех баффов стиля"""
            total = 0
            current_time = ctime.get()
            
            for buff in self.style_buffs:
                if buff['end_time'] > current_time:
                    total += buff['value']
            if self.energy < 5:
                total -= 1
            
            return total      
        
        def s_check(self):
            
            return self.cum_count < self.climax_max
        
        def add_buff(self, stat_name, value, duration=None, until_time=None, calendar=None):
            """
        Добавляет временный бафф к статистике.
        :param stat_name: Название характеристики.
        :param value: Значение баффа.
        :param duration: Продолжительность в часах (может быть None, если используется until_time).
        :param until_time: Время в формате Calendar 
        """
            if calendar is None:
                calendar = ctime
            
            """Расширенный метод add_buff с поддержкой баффов стиля"""
            if stat_name in self.STYLE_BUFF_TYPES:
                return self.add_style_buff(stat_name, value, duration, until_time, calendar)    
            
            
            current_value = getattr(self, stat_name, None)
            if current_value is None:
                raise ValueError(f"Характеристика {stat_name} не найдена.")
            
            min_val, max_val = self.limits.get(stat_name, (None, None))
            if min_val is None or max_val is None:
                raise ValueError(f"Пределы для {stat_name} не установлены.")
            
            
            if (value > 0 and current_value >= max_val) or (value < 0 and current_value <= min_val):
                print(f"Бафф на {stat_name} не может быть наложен: характеристика уже на пределе ({current_value}).")
                return
            
            
            current_time = calendar.get()
            end_time = until_time if until_time else current_time + duration
            
            
            effective_value = min(value, max_val - current_value) if value > 0 else max(value, min_val - current_value)
            
            
            self.buffs.append({"stat": stat_name, "value": effective_value, "end_time": end_time})
            self.apply_buff(stat_name, effective_value)
            return f"Бафф на {stat_name} ({effective_value}) успешно добавлен до {end_time}."
        
        def add_style_buff(self, buff_type, value, duration=None, until_time=None, calendar=None):
            """Добавляет бафф стиля с учетом особых правил"""
            old_looks = self.looks
            if buff_type not in self.STYLE_BUFF_TYPES:
                return False
            
            if calendar is None:
                calendar = ctime 
            current_time = calendar.get() if calendar else 0
            
            
            if until_time is None and duration is None:
                until_time = 24
            
            
            if until_time is not None and until_time < current_time:
                until_time += 24
            
            
            end_of_day = 24.0
            
            
            end_time = until_time if until_time else (current_time + duration)
            
            
            if buff_type == 'health':
                
                existing_health_buffs = [b for b in self.style_buffs if b['type'] == 'health']
                
                if value < 0:  
                    if existing_health_buffs:
                        
                        existing_health_buffs[0]['value'] += value
                        
                        
                        if existing_health_buffs[0]['value'] > 0:
                            existing_health_buffs[0]['value'] = 1
                    else:
                        
                        self.style_buffs.append({
                        'type': buff_type, 
                        'value': value, 
                        'end_time': end_of_day
                    })
                else:  
                    
                    self.style_buffs = [b for b in self.style_buffs if b['type'] != 'health']
                    
                    self.style_buffs = [b for b in self.style_buffs if b['type'] != 'makeup']
                    
                    self.style_buffs.append({
                    'type': buff_type, 
                    'value': 1, 
                    'end_time': end_of_day
                })
            elif buff_type == 'makeup':
                if value == 2:  
                    self.style_buffs = [b for b in self.style_buffs if b['type'] != buff_type]
                    self.style_buffs.append({'type': buff_type, 'value': value, 'end_time': end_time})
                elif value == 1 and not any(b['value'] == 2 for b in [b for b in self.style_buffs if b['type'] == buff_type]):
                    self.style_buffs.append({'type': buff_type, 'value': value, 'end_time': end_time})
            elif buff_type == 'tan':
                
                tan_buffs = [b for b in self.style_buffs if b['type'] == buff_type]
                current_tan = sum(b['value'] for b in tan_buffs) if tan_buffs else 0
                
                
                if not tan_buffs:
                    self.style_buffs.append({
                    'type': buff_type, 
                    'value': min(value, 3),  
                    'end_time': min(end_time, current_time + (4 * 24))  
                })
                
                elif value > current_tan:
                    self.style_buffs = [b for b in self.style_buffs if b['type'] != buff_type]
                    self.style_buffs.append({
                    'type': buff_type, 
                    'value': min(value, 3),
                    'end_time': min(end_time, current_time + (4 * 24))
                })
                
                elif value == current_tan:
                    self.style_buffs = [b for b in self.style_buffs if b['type'] != buff_type]
                    self.style_buffs.append({
                    'type': buff_type, 
                    'value': current_tan,
                    'end_time': min(end_time, current_time + (4 * 24))
                })
            else:  
                existing_buffs = [b for b in self.style_buffs if b['type'] == buff_type]
                if not existing_buffs:  
                    self.style_buffs.append({'type': buff_type, 'value': value, 'end_time': end_time})
            
            new_looks = self.looks
            if new_looks > old_looks:
                flying_text(get_local("looks_increase").format(new_looks - old_looks), "positive")
            elif new_looks < old_looks:
                flying_text(get_local("looks_decrease").format(old_looks - new_looks), "negative")
            
            return True
        
        def add_drunk_buff(self, level, duration=3, calendar=None):
            """
        Добавляет эффект опьянения определенного уровня
        
        Args:
            level (int): Уровень опьянения (1-3)
            duration (float): Длительность в часах
            calendar: Объект календаря
        """
            
            
            if self.drunk_buff_active:
                self.clear_drunk_buffs()
            
            if calendar is None:
                calendar = ctime
            current_time = calendar.get()
            end_time = current_time + duration
            
            
            effects = {
            1: {"desire": 1, "morality": -2},
            2: {"desire": 2, "morality": -5},
            3: {"desire": 3, "morality": -10}
        }
            
            
            for stat, value in effects[level].items():
                buff = {
                "stat": stat,
                "value": value,
                "end_time": end_time,
                "drunk_effect": True  
            }
                
                
                current_val = getattr(self, stat)
                min_val, max_val = self.limits[stat]
                
                if value > 0:  
                    if current_val + value > max_val:
                        buff["value"] = max_val - current_val
                else:  
                    if current_val + value < min_val:
                        buff["value"] = min_val - current_val
                
                if buff["value"] != 0:  
                    self.buffs.append(buff)
                    self.apply_buff(stat, buff["value"])
            
            
            self.buffs.append({
            "stat": "drunk_status",
            "value": level,
            "end_time": end_time,
            "drunk_effect": True
        })
            
            self.drunk_buff_active = True
        
        def clear_drunk_buffs(self):
            """Убирает все эффекты опьянения"""
            drunk_buffs = [buff for buff in self.buffs if "drunk_effect" in buff]
            for buff in drunk_buffs:
                self.remove_buff(buff)
            self.drunk_buff_active = False
        
        @property
        def drunk_status(self):
            """Возвращает текущий уровень опьянения на основе активных баффов"""
            return self.has_buff("drunk_status")
        
        @drunk_status.setter
        def drunk_status(self, value):
            """Запрещаем прямую установку значения"""
            if hasattr(self, '_drunk_status'):
                raise AttributeError("drunk_status нельзя изменять напрямую, используйте add_drunk_buff")
            self._drunk_status = 0  
        
        def apply_buff(self, stat_name, value):
            """
        Применяет бафф к характеристике.
        :param stat_name: Название характеристики.
        :param value: Значение баффа.
        """            
            current_value = getattr(self, stat_name)
            min_val, max_val = self.limits.get(stat_name, (None, None))
            new_value = current_value + value
            if min_val is not None and max_val is not None:
                new_value = max(min_val, min(max_val, new_value))
            setattr(self, stat_name, new_value)
            if stat_name not in ["drunk_status", "style"]:  
                stat_loc = get_local(f"s_{stat_name}")
                if value > 0:
                    flying_text(get_local("buff_applied").format(stat_loc, value), "positive")
                else:
                    flying_text(get_local("debuff_applied").format(stat_loc, abs(value)), "negative")
        
        def remove_buff(self, buff):
            """Удаляет бафф и откатывает изменения"""
            stat_name = buff["stat"]
            value = buff["value"]
            
            if stat_name != "drunk_status":
                
                current_val = getattr(self, stat_name)
                
                min_val, max_val = self.limits.get(stat_name, (None, None))
                new_val = current_val - value
                
                
                if min_val is not None and max_val is not None:
                    new_val = max(min_val, min(max_val, new_val))
                
                
                setattr(self, stat_name, new_val)
            
            
            
            if buff in self.buffs:
                self.buffs.remove(buff)
        
        
        def update_buffs(self, calendar=None):
            """
        Проверяет все активные баффы и удаляет те, у которых истекло время действия.
        Также обрабатывает ежедневные эффекты и сбрасывает health баффы в начале нового дня.
        """
            if calendar is None:
                calendar = ctime
            current_time = calendar.get()
            
            
            day_start = current_time - (current_time % 24)
            
            
            
            if current_time % 24 == 0.0:
                expired_buffs = [buff for buff in self.buffs if buff["end_time"] == 24.0 or buff["end_time"] <= current_time]
                for buff in expired_buffs:
                    self.remove_buff(buff)
                
                self.style_buffs = [buff for buff in self.style_buffs if buff["type"] != "health" and buff["end_time"] != 24.0 and buff["end_time"] > current_time]
            
            
            
            expired_buffs = [buff for buff in self.buffs if buff["end_time"] <= current_time]
            for buff in expired_buffs:
                self.remove_buff(buff)
            
            
            self.style_buffs = [buff for buff in self.style_buffs if buff["end_time"] > current_time]
            
            
            if current_time % 24 == 0.0:  
                for i, buff in enumerate(self.style_buffs):
                    if buff["type"] == "tan":
                        
                        old_value = buff["value"]
                        
                        if 'last_daily_update' not in buff or buff['last_daily_update'] < day_start:
                            buff["value"] = max(0, buff["value"] - 1)
                            buff['last_daily_update'] = day_start
                            print(f"Decreased tan buff from {old_value} to {buff['value']} at day start {day_start}")
        
        
        def has_buff(self, stat_name):
            """Проверяет наличие баффа и возвращает его силу"""
            if stat_name in self.STYLE_BUFF_TYPES:
                matching_buffs = [buff for buff in self.style_buffs if buff["type"] == stat_name]
                if matching_buffs:
                    return sum(buff["value"] for buff in matching_buffs)
            else:
                matching_buffs = [buff for buff in self.buffs if buff["stat"] == stat_name]
                if matching_buffs:
                    return sum(buff["value"] for buff in matching_buffs)
            return 0 
        
        def get_active_buffs(self):
            """Возвращает все активные баффы"""
            regular_buffs = [f"{buff['stat']}: {buff['value']} (до {buff['end_time']})" for buff in self.buffs]
            style_buffs = [f"{buff['type']}: {buff['value']} (до {buff['end_time']})" for buff in self.style_buffs]
            
            return {
            "regular_buffs": regular_buffs,
            "style_buffs": style_buffs
        }
        
        def clear_buff(self, stat_name, remove_all=False):
            """
        Удаляет баффы указанного параметра.
        
        Args:
            stat_name (str): Название параметра
            remove_all (bool): Если True - удаляет все баффы параметра, 
                            если False - только первый найденный
                             
        Returns:
            bool: True если был удален хотя бы один бафф, False если баффов не найдено
        """
            buffs_to_remove = [buff for buff in self.buffs if buff["stat"] == stat_name]
            
            if not buffs_to_remove:
                return False
            
            if not remove_all:
                buffs_to_remove = buffs_to_remove[:1]
            
            for buff in buffs_to_remove:
                
                self.apply_buff(stat_name, -buff["value"])
                self.buffs.remove(buff)
            
            return True    
        
        def get_base_morality(self):
            """Возвращает значение морали без учета временных дебаффов от опьянения"""
            drunk_debuff = sum(buff["value"] for buff in self.buffs 
                        if buff["stat"] == "morality" and "drunk_effect" in buff)
            return self.morality - drunk_debuff
        
        def get_drunk_effects(self):
            """Возвращает текущие активные эффекты опьянения"""
            effects = {}
            for buff in self.buffs:
                if "drunk_effect" in buff:
                    effects[buff["stat"]] = {
                    "value": buff["value"],
                    "end_time": buff["end_time"]
                }
            return effects
        
        
        def __str__(self):
            
            buffs_display = "\n".join([
            f"  - {buff['stat']}: {buff['value']} (until {buff['end_time']})"
            for buff in self.buffs
            ]) if self.buffs else "None"
            stats = ( 
            f"Total Look: {self.looks}",
            f"├─ Base Look: {self.BASE_LOOK}",
            f"├─ Permanent Items: {self.permanent_items}",
            f"└─ Style: {self.style}",
            f"Intrigue: {self.intrigue}",
            f"Intelligence: {self.intelligence}",
            f"Morality: {self.morality}",
            f"Corruption: {self.corruption}",
            f"Desire: {self.desire}",
            f"Energy: {self.energy}",
            f"Exgibic: {self.exg}",
            f"Fitness: {self.fitness}",
            f"anal: {self.anal}",
            f"minet: {self.minet}",
            f"Deep minet: {self.deep_minet}",
            f"Strip: {self.strip}",
            f"Model: {self.model}",
            f"Sex Exp: {self.s_exp}",
            f"Drunk Status: {self.drunk_status}",
            f"Husbant Relationship: {self.h_rel}",
            f"Justin Relationship: {self.j_rel}",
            f"Boss Relationship: {self.bo_rel}",
            f"Brother Relationship: {self.br_rel}",
            f"Запас еды: {self.eat}",
            f"Morality Days Count: {self.morality_days_count}",
            f"anal Count: {self.anal_count}",
            f"minet Count: {self.minet_count}",
            f"Deep minet Count: {self.deep_minet_count}",
            f"Climax Count: {self.cum_count}",
            f"Climax Max: {self.climax_max}",
            f"Active Buffs:\n{buffs_display}"
        )
            return "\n".join(stats)   

    class NPC_character:
        
        def __init__(self, name='', intrigue=0, love=0, fidelity=0, s_power=6, s_count_max=2, desire=0, s_approval=0, corruption=0, cuckold=0, free_relations=0, ill=0, viagra=0, love_fam=0, loc='', schedule=None):
            self.name = name
            self.intrigue = intrigue 
            self.love = love 
            self.fidelity = fidelity 
            self.cuckold = cuckold 
            self.s_power = s_power 
            self.s_count = s_count_max
            self.s_count_max = s_count_max
            self.corruption = corruption  
            self.free_relations = free_relations 
            self.ill = ill 
            self.viagra = viagra
            self.love_fam = love_fam
            self.s_approval = s_approval
            self.desire = desire
            self.loc = loc
            self.schedule = schedule if schedule else {}
            self.limits = {
            "intrigue": (0, 20),
            "love": (0, 20),
            "fidelity": (0, 5),
            "cuckold": (0, 5),
            "s_power": (0, 10),
            "s_count": (0, self.s_count_max),  
            "corruption": (0, 20),
            "free_relations": (0, 5),
            "ill": (0, 3),
            "desire": (0, 20),  
            "s_approval": (0, 100) 
        }
            self.love_shelley = 0
        
        def __getstate__(self):
            return self.__dict__
        
        def __setstate__(self, state):
            
            self.__dict__ = state
            if 'love_shelley' not in self.__dict__:
                self.love_shelley = 0  
        
        
        def update(self, stat_name, value):
            
            current_value = getattr(self, stat_name)
            old_value = current_value
            
            min_val, max_val = self.limits.get(stat_name, (None, None))
            new_value = current_value + value
            
            
            if min_val is not None and max_val is not None:
                new_value = max(min_val, min(max_val, new_value)) 
            
            
            
            
            if value != 0:
                stat_loc = get_local(f"npc_{stat_name}")
                char_name_loc = get_local(f"{self.name}")
                if value > 0:
                    flying_text(get_local("npc_stat_increase").format(char_name_loc, stat_loc, abs(value)), "positive")
                else:
                    flying_text(get_local("npc_stat_decrease").format(char_name_loc, stat_loc, abs(value)), "negative")  
            
            
            setattr(self, stat_name, new_value)
        
        def calculate_s_count(self):
            
            if self.s_power <= 0:
                s_power_val = 0
            elif 1 <= self.s_power <= 4:
                s_power_val = 1
            elif 5 <= self.s_power <= 6:
                s_power_val = 2
            elif self.s_power == 7:
                s_power_val = 3
            elif 8 <= self.s_power <= 9:
                s_power_val = 4
            else:  
                s_power_val = 5
            
            
            if self.ill == 1:
                max_ill_limit = 2
            elif self.ill == 2:
                max_ill_limit = 1
            elif self.ill == 3:
                max_ill_limit = 0
            else:
                max_ill_limit = None  
            
            
            if max_ill_limit is not None:
                
                s_count = min(s_power_val, max_ill_limit, self.s_count_max)
            else:
                
                s_count = min(s_power_val, self.s_count_max)
            
            
            if self.ill == 3:
                s_count = 0
            
            
            if s_count == 0 and self.viagra == 1:
                self.viagra = 0
                s_count = 1  
            
            
            s_count = min(s_count, self.s_count_max)
            
            self.s_count = s_count
            return self.s_count    
        
        
        def __str__(self):
            stats = (
            f"Name: {self.name}",
            f"Intrigue: {self.intrigue}",
            f"Love: {self.love}",
            f"Fidelity: {self.fidelity}",
            f"cuckold: {self.cuckold}",
            f"S-Power: {self.s_power}",
            f"S-Count: {self.s_count}/{self.s_count_max}",
            f"Corruption: {self.corruption}",
            f"Free Relations: {self.free_relations}",
            f"Illness: {self.ill}",
            f"Viagra: {self.viagra}",
            f"Love for spourge: {self.love_fam}",
            f"Approval: {self.s_approval}",
            f"Desire: {self.desire}"
        )
            return "\n".join(stats)




    class Calendar:
        """Класс для работы с календарем. Принимает дату и время с интервалом в полчаса, а также язык интерфейса"""
        def __init__(self, hours=0, minutes=0, day_of_week=1, month=1, monthday=1, year=2024, actor=None):
            self.hours = hours
            self.minutes = minutes
            self.day_of_week_num = day_of_week
            self.month_num = month
            self.year = year
            self.daycount = 0
            self.monthday = monthday
            self.day_of_week = day_of_week
            self.actor = actor
            
            
            self.weekdays_en = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
            self.weekdays_ru = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье']
            self.weekdays_sp = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado', 'domingo']
            self.weekdays_it = ['lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato', 'domenica']
            self.weekdays_ge = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag']
            self.weekdays_fr = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche']
            self.weekdays_cn = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日']
            self.weekdays_br = ['Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado', 'Domingo']
            self.weekdays_id = ['Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu', 'Minggu']
            
            
            
            self.months_en = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
            self.months_ru = ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря']
            self.months_sp = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre']
            self.months_it = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre']
            self.months_ge = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
            self.months_fr = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre']
            self.months_cn = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']
            self.months_br = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro']
            self.months_id = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 
                  'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember']
            
            
            self.lang_to_weekdays = {
            'english': self.weekdays_en,
            None: self.weekdays_ru, 
            'ru': self.weekdays_ru, 
            'sp': self.weekdays_sp,
            'it': self.weekdays_it,
            'ge': self.weekdays_ge,
            'fr': self.weekdays_fr,
            'cn': self.weekdays_cn,
            'br': self.weekdays_br,
            'id': self.weekdays_id,
        }
            
            self.lang_to_months = {
            'english': self.months_en,
            None: self.months_ru, 
            'ru': self.months_ru, 
            'sp': self.months_sp,
            'it': self.months_it,
            'ge': self.months_ge,
            'fr': self.months_fr,
            'cn': self.months_cn,
            'br': self.months_br,
            'id': self.months_id,
        }
            
            self.month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
            self.time_str = ""
            self.day_of_week_str = ""
            self.month_str = ""
            self.pending_hours = 0
            self.target_time = None
            self.recalc()
        
        @property
        def language(self):
            
            
            try:
                return preferences.language
            except NameError: 
                return None
        
        
        def recalc(self):
            if self.actor is not None:
                self.actor.update_buffs()
            else:
                
                pass
            
            
            
            
            current_lang_key = self.language
            if current_lang_key not in self.lang_to_weekdays:
                current_lang_key = None 
            
            self.day_of_week_str = self.lang_to_weekdays[current_lang_key][self.day_of_week_num - 1]
            self.month_str = self.lang_to_months[current_lang_key][self.month_num - 1]
            
            if self.language == 'english':
                period = 'AM' if self.hours < 12 else 'PM'
                hour_12_format = self.hours % 12
                hour_12_format = 12 if hour_12_format == 0 else hour_12_format
                self.time_str = f"{hour_12_format:02}:{int(self.minutes):02} {period}"
            else:
                self.time_str = f"{int(self.hours):02}:{int(self.minutes):02}"
            
            self.day_of_week = self.day_of_week_num
        
        def set_actor(self, actor):
            self.actor = actor
        
        def add(self, hours_to_add):
            log_debug_info()
            """Начинаем процесс пропуска времени на указанное количество часов"""
            self.pending_hours = hours_to_add
            self.skip()
        
        def skip(self):
            """Обрабатывает очередной интервал пропуска времени"""
            
            global prologue, renpy, fcs, manager
            
            if self.pending_hours <= 0:
                if not prologue:
                    renpy.jump(fcs.loc)
                return
            
            if prologue:
                total_minutes = int(self.pending_hours * 60)
                self.pending_hours = 0
                self.minutes += total_minutes
                self.hours += self.minutes // 60
                self.minutes %= 60
                if self.hours >= 24:
                    days_to_add = self.hours // 24
                    self.hours %= 24
                    self.add_days(days_to_add)
                self.recalc()
                manager.update_locations()
                renpy.block_rollback()
            else:
                time_step = min(0.5, self.pending_hours)
                self.pending_hours -= time_step
                total_minutes = int(time_step * 60)
                self.minutes += total_minutes
                self.hours += self.minutes // 60
                self.minutes %= 60
                if self.hours >= 24:
                    days_to_add = self.hours // 24
                    self.hours %= 24
                    self.add_days(days_to_add)
                self.recalc()
                manager.update_locations()
                renpy.block_rollback()
                renpy.jump("start_sandbox")
        
        def get(self):
            """Возвращает текущее время в цифровом формате, где .5 соответствует 30 минутам."""
            return self.hours + (0.5 if self.minutes == 30 else 0)
        
        def add_days(self, days_to_add):
            self.day_of_week_num = (self.day_of_week_num + days_to_add - 1) % 7 + 1
            self.daycount += days_to_add
            
            
            
            
            
            current_month_index = self.month_num - 1
            days_in_current_month = self.month_days[current_month_index]
            
            if self.month_num == 2 and (self.year % 4 == 0 and (self.year % 100 != 0 or self.year % 400 == 0)):
                days_in_current_month = 29
            
            
            temp_monthday = self.monthday + days_to_add
            
            while temp_monthday > days_in_current_month:
                temp_monthday -= days_in_current_month
                self.increment_month()
                current_month_index = self.month_num - 1
                days_in_current_month = self.month_days[current_month_index]
                if self.month_num == 2 and (self.year % 4 == 0 and (self.year % 100 != 0 or self.year % 400 == 0)):
                    days_in_current_month = 29
            
            
            self.monthday = temp_monthday
            self.recalc()
        
        
        def increment_month(self):
            self.month_num += 1
            if self.month_num > 12:
                self.month_num = 1
                self.year += 1
        
        
        def set(self, time):
            """Устанавливает время на указанное значение, корректно обрабатывая события."""
            current_time = self.get()
            target_time = float(time)
            
            if target_time < current_time:
                self.add(24 - current_time + target_time)
            else:
                self.add(target_time - current_time)
        
        def day_and_month_text(self):
            current_lang_key = self.language
            if current_lang_key not in self.lang_to_months:
                current_lang_key = None 
            
            month_name = self.lang_to_months[current_lang_key][self.month_num - 1]
            
            if self.language == 'english':
                return f"{month_name} {self.monthday}"
            elif self.language == 'cn':
                return f"{month_name}{self.monthday}日"
            
            else:
                return f"{self.monthday} {month_name}"
        
        
        def __call__(self):
            return self.get()
        
        def __str__(self):
            
            
            
            if self.language == 'english':
                return f"{self.day_of_week_str}, {self.month_str} {self.monthday}, {self.year} {self.time_str}"
            elif self.language == 'cn':
                return f"{self.month_str}{self.monthday}日 {self.year}, {self.day_of_week_str}, {self.time_str}"
            elif self.language in ['sp', 'it', 'ge', 'fr', 'br']: 
                
                return f"{self.monthday} {self.month_str} {self.year}, {self.day_of_week_str}, {self.time_str}"
            else: 
                
                return f"{self.monthday} {self.month_str} {self.year}, {self.day_of_week_str}, {self.time_str}"










    class Journal:
        
        def __init__(self, quest_id, branch=''):
            self.quest_id = quest_id  
            self.name = get_quests_local(quest_id, "name")  
            self.stage = 0  
            self.notification = False  
            self.expanded = True  
            self.branch = branch
            self.completed = False
            self.data_list = []  
        
        def set(self, stage, silent=False, completed=False):
            """Установить текущую стадию квеста."""
            previous_stage = self.stage
            self.stage = stage
            
            
            if stage not in self.data_list:
                self.data_list.append(stage)
            if completed:
                self.completed = True    
            
            
            if not silent:
                if previous_stage == 0:
                    flying_text(get_local("quest_new").format(name=self.name), style="achievement")
                elif completed:
                    flying_text(get_local("quest_completed").format(name=self.name), style="achievement")
                else:
                    flying_text(get_local("quest_updated").format(name=self.name), style="notification")
            
            
            self.notification = not silent
            
            
            renpy.block_rollback()
        
        def viewed(self):
            """Сбросить флаг уведомления."""
            self.notification = False
        
        def __str__(self):
            notification_str = " !!!" if self.notification else ""
            desc = (self.quest_id, self.stage)
            return f"{self.name} - Stage: {self.stage}, Description: {desc}, Data: {self.data_list} {notification_str}"







    import re
    def process_choice_text(text):
        if hasattr(store, 'difficulty'):
            if renpy.store.difficulty == "normal":
                
                return re.sub(r'\s*\([^)]*\)', '', text)
            else:
                
                return text
        else:
            
            return text


    import inspect
    def log_debug_info():
        
        last_lines = []
        for entry in reversed(renpy.store._history_list):
            if hasattr(entry, "what") and entry.what:
                last_lines.append(entry.what)
            if len(last_lines) == 3:
                break
        last_lines.reverse()
        
        
        last_scene_image = "<не определено>"
        layers = renpy.config.layers
        for layer in layers:
            shown = renpy.get_showing_tags(layer=layer)
            if shown:
                last_scene_image = next(iter(shown))
                break
        
        
        return_stack_output = pprint.pformat(renpy.game.context().return_stack)
        
        
        from renpy.store import ctime
        game_ctime = str(ctime)
        
        
        stack = inspect.stack()
        caller_info = "<неизвестно>"
        for frame in stack:
            if frame.filename.endswith(".rpy"):
                caller_info = f"{frame.filename} : строка {frame.lineno}"
                break
        
        
        log_text = "\n========== Переход времени ==========\n"
        log_text += f"Место вызова: {caller_info}\n"
        log_text += f"ctime (внутриигровое время): {game_ctime}\n"
        log_text += "Последние строки диалога:\n"
        for line in last_lines:
            log_text += f"    \"{line}\"\n"
        log_text += f"Показанное изображение: {last_scene_image}\n"
        log_text += "Return Stack:\n"
        log_text += return_stack_output + "\n"
        log_text += "======================================="
        
        
        renpy.log(log_text)



    def s_system_check(actor, rounds):
        
        if actor.s_power in (0, 1, 2, 3):
            thresholds = {0: 10, 1: 9, 2: 8, 3: 7}
            compare = thresholds[actor.s_power] + rounds // 2
            if rdice1(12) < compare:
                return True
        else:
            
            if rounds % 2 == 0:
                thresholds = {4: 6, 5: 5, 6: 4, 7: 3, 8: 2}
                if actor.s_power in thresholds:
                    compare = thresholds[actor.s_power] + rounds // 2
                    if rdice1(12) < compare:
                        return True
                else:
                    
                    if rdice1(12) < (1 + rounds // 2):
                        return True
        return False




    def s_select(last, n):
        
        if n == 1:
            return 1
        elif n == 2:
            return 2 if last == 1 else 1
        else:
            new_stance = rdice1(n)
            while new_stance == last:
                new_stance = rdice1(n)
            return new_stance

    def tskip(diss=1.0,paus=1): 
        renpy.scene()  
        renpy.show("black") 
        renpy.with_statement(Dissolve(diss)) 
        renpy.pause(delay=paus, hard=True)

    def t_mean(): 
        renpy.show_screen('meanwhile')
        renpy.with_statement(dissolve)
        renpy.pause(2)
        renpy.hide_screen('meanwhile')
        renpy.scene(layer='master')
        renpy.show('black', layer='master')
        renpy.with_statement(dissolve)  

    def t_pass(): 
        renpy.show_screen('pass_time')
        renpy.with_statement(dissolve)
        renpy.pause(2)
        renpy.hide_screen('pass_time')
        renpy.scene(layer='master')
        renpy.show('black', layer='master')
        renpy.with_statement(dissolve)   

    def t_before(): 
        renpy.show_screen('pass_before')
        renpy.with_statement(dissolve)
        renpy.pause(2)
        renpy.hide_screen('pass_before')
        renpy.scene(layer='master')
        renpy.show('black', layer='master')
        renpy.with_statement(dissolve)      

    def t_emma(): 
        renpy.show_screen('pass_emma')
        renpy.with_statement(dissolve)
        renpy.pause(2)
        renpy.hide_screen('pass_emma')
        renpy.scene(layer='master')
        renpy.show('black', layer='master')
        renpy.with_statement(dissolve)              


    def rdice(n, debug=False):
        
        global rdice_data
        key = f"rdice_{n}"
        if difficulty == "cheat":
            debug = True
        
        if key not in rdice_data:
            numbers = list(range(1, n+1))
            renpy.random.shuffle(numbers)
            rdice_data[key] = {
            "numbers": numbers,
            "index": 0
        }
        
        entry = rdice_data[key]
        
        if entry["index"] >= len(entry["numbers"]):
            renpy.random.shuffle(entry["numbers"])
            entry["index"] = 0
        
        value = entry["numbers"][entry["index"]]
        entry["index"] += 1
        
        
        if debug:
            result = renpy.call_screen("dice_debug", value=value, min_value=1, max_value=n)
            if result is not None:
                
                result = max(1, min(n, result))
                return result
        
        return value

    def rdice1(n):
        
        global rdice_data
        key = f"rdice_{n}"
        
        if key not in rdice_data:
            numbers = list(range(1, n+1))
            renpy.random.shuffle(numbers)
            rdice_data[key] = {
            "numbers": numbers,
            "index": 0
        }
        
        entry = rdice_data[key]
        
        if entry["index"] >= len(entry["numbers"]):
            renpy.random.shuffle(entry["numbers"])
            entry["index"] = 0
        
        value = entry["numbers"][entry["index"]]
        entry["index"] += 1
        
        
        return value    


    def vars_foo(value):
        global vars 
        if value not in vars:
            vars.append(value)    
            return True
        else:
            return False


    import pprint
    def debug_return_stack():
        print(pprint.pprint(renpy.game.context().return_stack))


    def time_integer(number):
        is_int = isinstance(number, int) or (isinstance(number, float) and number.is_integer())
        return is_int

    def create_and_add_quest(quest_id):
        
        branch = ""
        if quest_id.startswith("main_"):
            branch = "main"
        elif quest_id.startswith("character_"):
            branch = "character"
        elif quest_id.startswith("quest_"):
            branch = "quest"
        elif quest_id.startswith("work_"):
            branch = "work"
        elif quest_id.startswith("poss_"):
            branch = "poss"    
        
        
        quest = Journal(quest_id, branch=branch)
        globals()[quest_id] = quest
        
        
        if branch == "main":
            main_quests.append(quest)
        elif branch == "character":
            character_quests.append(quest)
        elif branch == "quest":
            quest_quests.append(quest)
        elif branch == "work":
            work_quests.append(quest)
        elif branch == "poss":
            poss_quests.append(quest)

    def reset_all_notifications(): 
        for quest_list in [main_quests, character_quests, quest_quests, work_quests]:
            for quest in quest_list:
                quest.viewed()

    def reset_poss_notifications(): 
        for quest in poss_quests:
            quest.viewed()            


    def get_quest_name_style(quest): 
        if quest.notification:
            return "quest_name_notification_text"
        elif quest.completed:
            return "quest_name_completed_text"
        else:
            return "quest_name_text"

    def get_quest_description_style(quest): 
        if quest.notification:
            return "quest_description_notification_text"
        elif quest.completed:
            return "quest_description_completed_text"
        else:
            return "quest_description_text"          

    def set_font(font_name):
        gui.text_font = font_name
        renpy.restart_interaction()       

    def increase_energy_limit_robe(): 
        fcs.limits["energy"] = (fcs.limits["energy"][0], fcs.limits["energy"][1] + 1)    


    class NPCManager:
        def __init__(self, calendar):
            self.calendar = calendar
            self.npcs = npcs_list
        
        def update_locations(self):
            """
        Обновляет значение loc для всех NPC в соответствии с текущим временем и днем недели.
        """
            current_time = self.calendar.get()
            current_day = self.calendar.day_of_week
            for npc in self.npcs:
                if npc.schedule.get(current_day):
                    npc.loc = self.get_location_for_time(npc.schedule[current_day], current_time)
                
                else:
                    npc.loc = "unknown"
                print(f"{npc.name}, {npc.loc} {current_day}, {current_time}")
        
        
        @staticmethod
        def get_location_for_time(schedule, current_time):
            """
        Определяет местоположение NPC на основе его расписания и текущего времени.
        :param schedule: Список кортежей (start_time, end_time, location) для текущего дня.
        :param current_time: Текущее время в цифровом формате.
        :return: Местоположение (строка).
        """
            for start_time, end_time, location in schedule:
                if start_time <= current_time <= end_time:
                    return location
            
            
            return "unknown"     

    class PhoneChat:
        def __init__(self, player_key="player", other_key="friend"):
            self.player_key = player_key
            self.other_key = other_key
            self.current_speaker_key = other_key
            self.messages = []
            
            
            
            
            self.max_total_cost = 680 
            
            
            
            self.cost_per_char = 1
            
            
            
            
            
            self.cost_per_line = 30 
            
            
            self.cost_per_message_overhead = 25 
            
            
            
            self.cost_per_image = 150 
            
            
            self.current_total_cost = 0
            
            
            
            self.chars_per_line_estimate = 40 
        
        
        
        def _calculate_message_cost(self, text, image):
            cost = self.cost_per_message_overhead
            
            if text:
                text_len = len(text)
                
                num_lines = 1 + (text_len // self.chars_per_line_estimate)
                
                cost += num_lines * self.cost_per_line
            
            
            
            if image:
                cost += self.cost_per_image
            
            return cost
        
        def add_message(self, text_key=None, image=None, speaker_key=None):
            if speaker_key is None:
                speaker_key = self.current_speaker_key
            
            speaker_name = get_local(speaker_key)
            message_text = get_local(text_key) if text_key else None
            is_player = speaker_key == self.player_key
            
            
            new_message_cost = self._calculate_message_cost(message_text, image)
            
            
            
            while self.current_total_cost + new_message_cost > self.max_total_cost and self.messages:
                
                removed_message = self.messages.pop(0)
                
                self.current_total_cost -= removed_message.get("cost", 0) 
                
                self.current_total_cost = max(0, self.current_total_cost)
            
            
            
            message_data = {
            "text": message_text,
            "image": image,
            "speaker_key": speaker_key,
            "speaker_name": speaker_name,
            "is_player": is_player,
            "cost": new_message_cost 
        }
            
            
            self.messages.append(message_data)
            
            self.current_total_cost += new_message_cost
            
            return self
        
        def set_speaker(self, speaker_key):
            self.current_speaker_key = speaker_key
            return self
        
        def clear(self):
            self.messages = []
            self.current_total_cost = 0 
            return self
        
        def get_current_other_name(self):
            return get_local(self.other_key)





    class Fantasy:
        def __init__(self):
            self.images = []  
            self.fin = None   
            self.index = 0    
            self.timer = 15.0  
            self.first_time = True  
            self.instruction_step = 0  
            self.should_close = False  
            self.is_finished = False   
            self.current_image_path = None  
            self.fin_image_path = None  
        
        def next_image(self):
            """Переключает на следующее изображение в списке по кругу"""
            if len(self.images) > 0:
                self.index = (self.index + 1) % len(self.images)
                self.update_image_path()
        
        def update_image_path(self):
            """Обновляет пути к изображениям"""
            if 0 <= self.index < len(self.images):
                self.current_image_path = "images/" + self.images[self.index] + ".webp"
            else:
                self.current_image_path = None
            
            if self.fin:
                self.fin_image_path = "images/" + self.fin + ".webp"
            else:
                self.fin_image_path = None
        
        def reset(self):
            """Сбрасывает состояние для нового показа"""
            self.index = 0
            self.timer = 15.0
            self.should_close = False
            self.is_finished = False
            if self.first_time:
                self.instruction_step = 1
            else:
                self.instruction_step = 0
            self.update_image_path()
        
        def advance_instruction(self):
            """Продвигает инструкции и переключает изображение"""
            if self.first_time:
                self.instruction_step += 1
                if self.instruction_step > 4:
                    self.first_time = False
                    self.instruction_step = 0
                self.next_image()
        
        def clear(self):
            """Очищает все данные"""
            self.images = []
            self.fin = None
            self.index = 0
            self.should_close = False
            self.is_finished = False
            self.current_image_path = None
            self.fin_image_path = None
        
        def decrease_timer(self):
            """Уменьшает таймер и проверяет необходимость закрытия"""
            if self.timer > 0:
                self.timer -= 1.0
            else:
                self.is_finished = True
        
        def mark_as_finished(self):
            """Отмечает, что необходимо показать финальное изображение"""
            self.is_finished = True
        
        def mark_for_closing(self):
            """Отмечает, что экран должен быть закрыт"""
            self.should_close = True



    def get_local(key):
        if preferences.language is None:
            return screens_locs_ru.get(key, "")
        elif preferences.language == "english":
            return screens_locs_en.get(key, "")
        elif preferences.language == "it":
            return screens_locs_it.get(key, "")
        elif preferences.language == "sp":
            return screens_locs_sp.get(key, "")
        elif preferences.language == "de":
            return screens_locs_de.get(key, "")
        elif preferences.language == "fr":
            return screens_locs_fr.get(key, "")
        elif preferences.language == "cn":
            return screens_locs_cn.get(key, "")
        elif preferences.language == "br":
            return screens_locs_br.get(key, "")
        elif preferences.language == "id":
            return screens_locs_id.get(key, "")
        else:
            return screens_locs_en.get(key, "")  



    def get_quests_local(quest_id, key):
        if preferences.language is None:
            return quest_data_ru.get(quest_id, {}).get(key, "")
        elif preferences.language == "english":
            return quest_data_en.get(quest_id, {}).get(key, "")
        elif preferences.language == "it":
            return quest_data_it.get(quest_id, {}).get(key, "")
        elif preferences.language == "sp":
            return quest_data_sp.get(quest_id, {}).get(key, "")
        elif preferences.language == "de":
            return quest_data_de.get(quest_id, {}).get(key, "")
        elif preferences.language == "fr":
            return quest_data_fr.get(quest_id, {}).get(key, "")
        elif preferences.language == "cn":
            return quest_data_cn.get(quest_id, {}).get(key, "")
        elif preferences.language == "br":
            return quest_data_br.get(quest_id, {}).get(key, "")
        elif preferences.language == "id":
            return quest_data_id.get(quest_id, {}).get(key, "")
        else:
            return quest_data_en.get(quest_id, {}).get(key, "") 


    def get_buff_display(stat_name):
        """
    Возвращает строку с отображением баффов для экрана персонажа.
    """
        total_buff = sum(buff['value'] for buff in fcs.buffs if buff['stat'] == stat_name)
        if total_buff > 0:
            return f" {{color=#00FF00}}(+{total_buff}){{/color}}"
        elif total_buff < 0:
            return f" {{color=#FF0000}}({(total_buff)}){{/color}}"
        return ""

    def add_npc(new_npc): 
        if len(npcs_list) < 6:
            npcs_list.append(new_npc)
        elif len(npcs_list2) < 6:
            npcs_list2.append(new_npc)
        else:
            npcs_list3.append(new_npc)
        flying_text(get_local("new_character"), style="achievement")   


    def switch_language_and_style(language_code):
        
        renpy.change_language(language_code)
        
        
        
        
        
        
        renpy.restart_interaction()

    def change_dialogue_font(font_name):
        
        if font_name in ["FontPTC55F", "FontItalian", "FontSpecialElite", "FontNotoSerifSC"]:
            
            renpy.set_style_preference("dialog_font", font_name)
            renpy.restart_interaction()

    def get_text_style():
        if preferences.language == "cn":
            return "default"
        else:
            return "elite_default"        


    class ShopItem(store.object):  
        def __init__(self, name, price, description="", effects=None, condition=None):
            self.name = name  
            self.price = price 
            self.description = description
            self.effects = effects if effects else []              
            self.condition = condition 


    def buy_item(item):
        
        condition_met = renpy.eval(item.condition) if item.condition else True
        if fcs.money >= item.price and item.name not in fcs.inv and condition_met:
            fcs.money -= item.price
            fcs.inv.append(item.name)
            
            for effect in item.effects:
                
                if isinstance(effect, tuple):
                    method, *args = effect
                    method(*args)
                else:
                    effect()   
            
            renpy.restart_interaction()        
            flying_text(get_local("shop_buy"), style="achievement")  
        else:
            renpy.notify("Не удалось совершить покупку.") 


    class FlyingTextQueue: 
        def __init__(self):
            self.active_messages = []  
            self.queue = [] 
            self.last_slot = -1 
            self.processing = False  
        
        def add(self, text, style="notification"):
            
            if renpy.is_skipping() or renpy.get_roll_forward() or renpy.in_rollback():
                return
            
            
            self.queue.append({
            "text": text,
            "style": style
        })
            
            
            if not self.processing:
                self.processing = True
                self.process_queue()
            
            
            
            renpy.block_rollback()
        
        
        def process_queue(self): 
            while self.queue:
                
                msg = self.queue.pop(0)
                
                
                self.last_slot = (self.last_slot + 1) % 3
                xpositions = [0.13, 0.5, 0.87]
                
                
                self.active_messages.append({
                "text": msg["text"],
                "style": msg["style"],
                "xpos": xpositions[self.last_slot],
                "slot_index": self.last_slot
            })
            
            
            
            self.processing = False

    def flying_text(text, style="notification"):
        """
    Добавляет летающий текст с указанным стилем.
    Стили: notification (по умолчанию), negative, positive, achievement.
    """
        flying_text_queue.add(text, style)










    def print_screen_layers1():
        for layer in renpy.config.layers:
            for tag, zorder in renpy.get_zorder_list(layer):
                screen_info = renpy.get_screen(tag, layer)
                if screen_info and hasattr(screen_info, 'name'):  
                    print(f"Имя экрана: {screen_info.name}, тег: {tag}, слой: {layer}, порядок: {zorder}")             

    class My_Revenues:
        def __init__(self):
            
            self.husband_job = 3000  
            self.job_1 = 1000       
            self.job_2 = 0
            self.job_3 = 0
            self.job_4 = 0
            self.job_5 = 0
            
            
            self.spending_1 = 3500  
            self.spending_2 = 300   
            self.spending_3 = 0
            self.spending_4 = 0
            self.spending_5 = 0
        
        def get_total_income(self):
            
            return (self.husband_job + self.job_1 + self.job_2 + 
                self.job_3 + self.job_4 + self.job_5)
        
        def get_total_spending(self):
            
            return (self.spending_1 + self.spending_2 + self.spending_3 + 
                self.spending_4 + self.spending_5)
        
        def get_balance(self):
            
            return self.get_total_income() - self.get_total_spending()
        
        def get_active_incomes(self):
            
            incomes = []
            if self.husband_job > 0:
                incomes.append((get_local("income_tyler"), self.husband_job)) 
            if self.job_1 > 0:
                incomes.append((get_local("income_emma1"), self.job_1))
            if self.job_2 > 0:
                incomes.append(("Работа 2", self.job_2))
            if self.job_3 > 0:
                incomes.append(("Работа 3", self.job_3))
            if self.job_4 > 0:
                incomes.append(("Работа 4", self.job_4))
            if self.job_5 > 0:
                incomes.append(("Работа 5", self.job_5))
            return incomes
        
        def get_active_spendings(self):
            
            spendings = []
            if self.spending_1 > 0:
                spendings.append((get_local("spending_mort"), self.spending_1))
            if self.spending_2 > 0:
                spendings.append((get_local("spending_food"), self.spending_2))
            if self.spending_3 > 0:
                spendings.append(("Расход 3", self.spending_3))
            if self.spending_4 > 0:
                spendings.append(("Расход 4", self.spending_4))
            if self.spending_5 > 0:
                spendings.append(("Расход 5", self.spending_5))
            return spendings                


transform flying_transform(slot_index):

    alpha 0.0
    yanchor 1.0
    ypos 0.55
    zoom 1.0
    parallel:
        easeout 2.5 ypos 0.1
    parallel:
        linear 0.1 alpha 1
        linear 1.8 alpha 1.0
        linear 0.6 alpha 0.0
    parallel:
        ease 2.5 zoom .9

screen flying_messages():
    zorder 100

    for msg in flying_text_queue.active_messages:
        add Text(msg["text"], style=msg["style"], xalign=msg["xpos"]) at flying_transform(msg["slot_index"])

default flying_text_queue = FlyingTextQueue()



style notification:
    color "#FFFFFF"
    size 28
    text_align 0.5
    outlines [(2, "#000000", 1, 1)]

style negative:
    color "#FF4444"
    size 28
    bold True
    text_align 0.5
    outlines [(2, "#000000", 1, 1)]

style positive:
    color "#44FF44"
    size 28
    bold True
    text_align 0.5
    outlines [(2, "#000000", 1, 1)]

style achievement:
    color "#FFD700"
    size 32
    bold True
    text_align 0.5
    outlines [(2, "#000000", 1, 1)]
return
# Decompiled by unrpyc: https://github.com/CensoredUsername/unrpyc
